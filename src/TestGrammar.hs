-- automatically generated by BNF Converter
module Main where


import           System.Environment   (getArgs, getProgName)
import           System.Exit          (exitFailure, exitSuccess)
import           System.IO            (hGetContents, stdin)

import           Grammar.AbsGrammar
import           Grammar.ErrM
import           Grammar.LexGrammar
import           Grammar.ParGrammar
import           Grammar.PrintGrammar
import           Grammar.SkelGrammar

import           Utils.JVM

import           Control.Monad

type ParseFun a = [Token] -> Err a

myLLexer = myLexer

type Verbosity = Int

putStrV :: Verbosity -> String -> IO ()
putStrV v s = when (v > 1) $ putStrLn s

runFile :: Verbosity -> ParseFun Program -> FilePath -> IO ()
runFile v p f = putStrLn f >> readFile f >>= run v p

run :: Verbosity -> ParseFun Program -> String -> IO ()
run v p s = let ts = myLLexer s in case p ts of
           Bad s    -> do putStrLn "\nParse              Failed...\n"
                          putStrV v "Tokens:"
                          putStrV v $ show ts
                          putStrLn s
                          exitFailure
           Ok  tree -> do putStrLn "\nParse Successful!"
                          putStrLn $ "\n depths" ++ show (depth tree)
                          showTree v tree

                          exitSuccess


showTree :: (Show a, Print a) => Int -> a -> IO ()
showTree v tree
 = do
      putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
      putStrV v $ "\n[Linearized tree]\n\n" ++ printTree tree

main :: IO ()
main = do
  args <- getArgs
  case args of
    [] -> getContents >>= run 2 pProgram
    fs -> mapM_ (runFile 2 pProgram) fs
